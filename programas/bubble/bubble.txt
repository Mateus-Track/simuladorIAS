M(0) -> Contém o número 0 (resetar contadores)
M(1) -> Contém o número 1 (Incrementar)
M(2) -> indice i (começa em 0)
M(3) -> indice j (começa em 0)
M(4) -> Variável auxiliar (Começa em 0)
M(5) -> Tem o tamanho do vetor (N <= 100)
M(6) -> Onde começa o array

Interval M(7) to M(106) contains the array values; 
The instruction section begins at M(107);
In the implementation below, consider the array A:
A length = 10;
A offset = 7;
A values = [32, 12, 2, 8, 11, 3, 9, 40, 1, 7];
2.3 Bubble sort IAS Code:
It must be remembered that the instructions start at line 108 (M(107)), since the lines 8 - 107 (M(7) to M(106)) are allocated to store array values. That is why the .txt file contains continuous blank lines until line 108, where the instruction syntax actually begins.
In the example below, M(7) - M(16) contains the array values. M(5) contains the array length. If we were to add more values, M(5) would have to correspond to the number of values added. For example, adding 1, 2 in M(17) and M(18) would require increasing M(5) to 12.

./a.out -p src/tests/bubble-sort.txt -i 107


# numeric syntax

00	0
01	1 
02	0
03 	0
04	0
05	10
06	7
07	32
08	12
09	2
10	8
11	11
12	3
13	9
14	40
15	1
16	7
17	
…
106	

# instruction syntax

# AC = A[j] address

107	load m(6)
107	add m(3)

# address modify (A[j])

108	stor m(112,8:19) 
108	stor m(113,8:19)
109	stor m(114,28:39)

# AC = A[j+1] address

109	add m(1)

# address modify (A[j+1])

110	stor m(111,28:39) 
110	stor m(114,8:19) 
111	stor m(115,28:39)

# if A[j] <= A[j+1], jump to left side of M(116)
# A[j] <= A[j+1] ≡ A[j+1] - A[j] >= 0 

111	load m(0)
112	sub m(0)
112	jump+ m(116, 0:19)

# aux = A[j]

113	load m(0)
113	stor m(4)

# A[j] = A[j+1]

114	load m(0)	 
114	stor m(0)

# A[j+1] = aux

115	load m(4)	 
115	stor m(0)

# increment j

116	load m(3)
116	add m(1)
117	stor m(3)



# if j < n-i-1, repeat again
# ≡ n-i-1-j > 0 ≡ n-i-1-j-1 > -1

117	load m(5)
118	sub m(2)
118	sub m(1)
119	sub m(3)
119	sub m(1)
120	jump+ m(107,0:19)

# reset j

120	load m(0)
121	stor m(3)

# increment i

121	load m(2)
122	add m(1)
122	stor m(2)

# if i < n-1, repeat again
# ≡ n-1-i > 0 ≡ n-1-i-1 > -1

123	load m(5)
123	sub m(1)
124	sub m(2)
124	sub m(1)
125	jump+ m(107,0:19)

# exit

125	exit